---
layout: landing
title: Mojave Architecture File Storage
description: The protocol for open audio distribution.
showTopNav: false
showSidebar: true
---

# Lazy DEK Replication & P2P Discovery

A decentralized key management architecture for encrypted content distribution using OpenTDF/NanoTDF.

## Overview

Traditional encrypted file systems require users to pre-distribute encryption keys to all parties who might need access. This design flips that model:

- **Publisher uploads once** to a single validator
- **DEKs replicate lazily** across the network based on policy
- **Decryption is load-balanced** across any validator holding the DEK
- **Users discover DEK holders** via P2P queries

## Architecture

```mermaid
flowchart TB
    subgraph user [Publisher]
        U[User]
    end
    
    subgraph storage [Decentralized Storage]
        IPFS[(IPFS / Filecoin)]
    end
    
    subgraph chain [CometBFT Chain]
        TX[FileUpload TX]
        STATE[(On-Chain State)]
    end
    
    subgraph validators [Validator Network]
        V1[Validator 1<br/>Initial Authority]
        V2[Validator 2]
        V3[Validator 3]
        V4[Validator 4]
    end
    
    U -->|1. Upload NanoTDF| IPFS
    U -->|2. Submit TX with wrapped DEK| V1
    V1 -->|3. Finalize TX| STATE
    V1 <-->|4. Async DEK sharing| V2
    V1 <-->|4. Async DEK sharing| V3
    V2 <-->|4. Async DEK sharing| V4
```

## Upload Flow

When a user uploads encrypted content, they only interact with a single validator.

```mermaid
sequenceDiagram
    participant U as User
    participant IPFS as IPFS
    participant V1 as Validator 1
    participant Chain as CometBFT
    
    Note over U: 1. Encrypt file with DEK
    U->>U: Generate DEK
    U->>U: Encrypt payload → NanoTDF
    U->>U: Wrap DEK for self
    U->>U: Wrap DEK for V1
    
    Note over U,IPFS: 2. Store encrypted file
    U->>IPFS: Upload NanoTDF
    IPFS-->>U: CID: Qm...
    
    Note over U,Chain: 3. Register on-chain
    U->>V1: FileUpload TX
    
    Note right of V1: TX contains:<br/>- CID<br/>- Wrapped DEKs<br/>- Replication policy<br/>- Policy binding
    
    V1->>Chain: Propose TX
    Chain->>Chain: Consensus
    Chain-->>V1: TX Finalized
    V1-->>U: Success ✓
    
    Note over U: User goes offline
```

## Lazy DEK Replication

After the upload TX is finalized, validators asynchronously replicate the DEK based on the replication policy.

```mermaid
sequenceDiagram
    participant V1 as Validator 1<br/>(has DEK)
    participant V2 as Validator 2
    participant V3 as Validator 3
    participant V4 as Validator 4
    
    Note over V1,V4: Replication Policy: "validators"
    
    V2->>V2: See FileUpload TX
    V2->>V2: Check: Am I in replication policy?
    V2->>V1: RequestDEK(CID, myPubKey, proof)
    
    Note right of V1: V1 verifies:<br/>- V2 is active validator<br/>- Policy allows V2
    
    V1-->>V2: WrappedDEK (for V2's key)
    V2->>V2: Store DEK locally
    
    par Parallel replication
        V3->>V1: RequestDEK(CID, myPubKey, proof)
        V1-->>V3: WrappedDEK (for V3's key)
    and
        V4->>V2: RequestDEK(CID, myPubKey, proof)
        V2-->>V4: WrappedDEK (for V4's key)
    end
    
    Note over V1,V4: DEK now available on V1, V2, V3, V4
```

## DEK Discovery & Decryption

When a user needs to decrypt, they query the network to find any validator holding the DEK.

```mermaid
sequenceDiagram
    participant U as User
    participant Net as P2P Network
    participant V3 as Validator 3
    participant IPFS as IPFS
    
    U->>IPFS: Fetch NanoTDF by CID
    IPFS-->>U: NanoTDF blob
    
    U->>U: Parse header, extract locator
    
    Note over U,Net: Discovery: Who has the DEK?
    U->>Net: Query: DEK holders for CID?
    Net-->>U: [V1, V2, V3, V4]
    
    U->>U: Pick best (nearest, fastest)
    
    Note over U,V3: Rewrap request
    U->>V3: RewrapRequest(CID, myPubKey)
    
    V3->>V3: Verify user entitlements
    V3->>V3: Check policy (ABAC + dissem)
    V3->>V3: Unwrap DEK
    V3->>V3: Rewrap for user's key
    
    V3-->>U: RewrappedDEK
    
    U->>U: Derive symmetric key
    U->>U: Decrypt payload ✓
```

## Replication Policies

Publishers control how their DEKs propagate through the network.

```mermaid
flowchart LR
    subgraph policies [Replication Policies]
        ALL[validators<br/>All active validators]
        SPECIFIC[specific<br/>Named entities only]
        NONE[none<br/>Initial authority only]
        ABAC[attributes<br/>Based on validator attributes]
    end
    
    subgraph examples [Examples]
        E1[Public content<br/>→ all validators]
        E2[Regional content<br/>→ EU validators only]
        E3[Private content<br/>→ user + 1 trusted validator]
        E4[Enterprise content<br/>→ validators with clearance]
    end
    
    ALL --> E1
    SPECIFIC --> E2
    NONE --> E3
    ABAC --> E4
```

## On-Chain State

```mermaid
erDiagram
    FileRecord {
        string cid PK "IPFS Content ID"
        address publisher "Who uploaded"
        address initial_authority "First validator with DEK"
        string policy_binding "HMAC(DEK, policy)"
        timestamp created_at
    }
    
    ReplicationPolicy {
        string cid FK
        string type "validators | specific | none | attributes"
        array entities "If specific, list of addresses"
        array attributes "If ABAC-based"
    }
    
    DEKHolder {
        string cid FK
        address validator PK
        timestamp acquired_at
    }
    
    FileRecord ||--|| ReplicationPolicy : has
    FileRecord ||--o{ DEKHolder : "replicated to"
```

## Forward-If-Not-Have Pattern

Any validator can handle decrypt requests, forwarding if they don't have the DEK.

```mermaid
flowchart TD
    REQ[Decrypt Request] --> CHECK{Do I have<br/>the DEK?}
    
    CHECK -->|Yes| POLICY{Check<br/>policy}
    POLICY -->|Authorized| REWRAP[Rewrap DEK<br/>for user]
    POLICY -->|Denied| DENY[Return: Unauthorized]
    REWRAP --> RETURN[Return: Rewrapped DEK]
    
    CHECK -->|No| FIND{Find DEK<br/>holder?}
    FIND -->|Found| FORWARD[Forward request<br/>to holder]
    FIND -->|Not found| NOTFOUND[Return: DEK Not Found]
    FORWARD --> RETURN
```

## Validator Departure

When a validator leaves the active set, they naturally lose the ability to service requests.

```mermaid
timeline
    title DEK Access Over Time
    
    section Epoch 1
        Upload : User wraps DEK for V1
               : V1 shares with V2, V3, V4
    
    section Epoch 2
        Active : V1, V2, V3, V4 can service requests
    
    section Epoch 3
        V1 Leaves : V1 deregisters from validator set
                  : V1 still has wrapped DEK locally
                  : Chain rejects V1's rewrap TXs
                  : V2, V3, V4 continue servicing
    
    section Epoch 4
        New Upload : New files don't include V1
                   : V1 never receives new DEKs
```

## Security Properties

| Property | Guarantee |
|----------|-----------|
| **Publisher control** | Only publisher decides initial DEK distribution |
| **Policy enforcement** | All rewrap requests validate ABAC policy |
| **Validator accountability** | Rewrap TXs are on-chain, auditable |
| **Departed validator exclusion** | Chain rejects non-active validators |
| **No single point of failure** | Any DEK holder can service requests |
| **Lazy replication** | DEKs spread on-demand, not upfront |

## Client Interface

From the user's perspective, complexity is hidden:

```mermaid
flowchart LR
    subgraph client [Client SDK]
        ENCRYPT[encrypt]
        UPLOAD[upload]
        DECRYPT[decrypt]
    end
    
    subgraph hidden [Hidden Complexity]
        DEK[DEK Generation]
        WRAP[Key Wrapping]
        IPFS[IPFS Upload]
        TX[TX Submission]
        DISCOVERY[P2P Discovery]
        REWRAP[Rewrap Protocol]
    end
    
    ENCRYPT --> DEK --> WRAP
    UPLOAD --> IPFS --> TX
    DECRYPT --> DISCOVERY --> REWRAP
    
    style hidden fill:#f0f0f0,stroke:#999
```

```go
// Simple client API
client := opentdf.NewClient(chainConfig)

// Upload (handles DEK, wrapping, IPFS, TX)
cid, err := client.Upload(fileBytes, Policy{
    Attributes: []string{"clearance/secret"},
    Replication: "validators",
})

// Decrypt (handles discovery, rewrap, decryption)
plaintext, err := client.Decrypt(cid)
```

## Comparison: Traditional vs Lazy Replication

```mermaid
flowchart TB
    subgraph traditional [Traditional Model]
        T1[User encrypts] --> T2[User wraps DEK for ALL recipients]
        T2 --> T3[User distributes to ALL]
        T3 --> T4[Each recipient stores]
    end
    
    subgraph lazy [Lazy Replication Model]
        L1[User encrypts] --> L2[User wraps DEK for 1 validator]
        L2 --> L3[Single TX submission]
        L3 --> L4[Validators async replicate]
        L4 --> L5[DEK available network-wide]
    end
    
    style traditional fill:#ffeeee
    style lazy fill:#eeffee
```

| Aspect | Traditional | Lazy Replication |
|--------|-------------|------------------|
| User effort | High (wrap for all) | Low (wrap for one) |
| Network calls | O(n) recipients | O(1) validator |
| DEK availability | Immediate | Eventually consistent |
| Publisher online time | Until all distributed | Until TX confirmed |
| Validator coordination | None | P2P DEK sharing |

## Implementation Notes

### NanoTDF for Storage Efficiency

NanoTDF is ideal for this architecture:

- **Compact**: < 200 bytes overhead
- **Self-contained**: Header includes locator and policy
- **ECC-based**: Compatible with blockchain cryptography
- **Single blob**: One CID per file, no manifest separation

### Key Derivation Flow

```mermaid
flowchart LR
    subgraph encrypt [Encryption]
        EPH[Ephemeral Key] --> ECDH1[ECDH]
        VAL_PUB[Validator PubKey] --> ECDH1
        ECDH1 --> HKDF1[HKDF]
        HKDF1 --> DEK[DEK]
        DEK --> AES[AES-GCM Encrypt]
    end
    
    subgraph rewrap [Rewrap]
        VAL_PRIV[Validator PrivKey] --> ECDH2[ECDH]
        EPH2[Ephemeral from header] --> ECDH2
        ECDH2 --> HKDF2[HKDF]
        HKDF2 --> DEK2[Recover DEK]
        DEK2 --> WRAP[Wrap for user]
        USER_PUB[User PubKey] --> WRAP
    end
```

## Summary

This architecture achieves:

1. **Minimal publisher burden** — Upload to one validator, done
2. **Network-level key distribution** — Validators handle replication
3. **Resilient decryption** — Any validator with DEK can serve
4. **Publisher-defined policies** — Full control over who gets access
5. **Natural validator churn handling** — Departed validators excluded automatically
6. **Auditable access** — All rewraps are on-chain transactions
7. **Decentralized storage** — Encrypted files on IPFS, keys managed by validators

